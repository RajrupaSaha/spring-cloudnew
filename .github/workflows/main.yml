name: Java App CI/CD to Kubernetes

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch: # Allows manual trigger

env:
  REGISTRY: ghcr.io # Or docker.io, your.private.registry.com
  IMAGE_NAME: ${{ github.repository }} # e.g., your-org/your-repo
  APP_NAME: java-app # Your application name, used for Helm release name
  HELM_CHART_PATH: ./helm/java-app # Path to your Helm chart directory within the repository

jobs:
  build-test-security:
    name: Build, Test & Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven' # Cache Maven dependencies

      - name: Build with Maven
        run: mvn clean install -DskipTests

      - name: Run Unit Tests
        run: mvn test

#      - name: Run Snyk Security Scan (SCA/SAST)
        # Note: This step requires a SNYK_TOKEN secret configured in your repository.
        # It scans for known vulnerabilities in your dependencies and code.
#        uses: snyk/actions/maven@master
#        env:
 #         SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
#        with:
 #         args: --all-projects # Scans all modules if it's a multi-module project

  docker-build-scan-push:
    name: Docker Build, Scan & Push
    runs-on: ubuntu-latest
    needs: build-test-security # Ensures build, test, and security scan pass first

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: rajrupanew # Uses GitHub Actions built-in token for GHCR
          password: Fukey202954$ # Or ${{ secrets.DOCKER_TOKEN }} for Docker Hub

      - name: Build and Push Docker image
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile # Assuming Dockerfile is in the root of the repository
          push: true
          tags: |
            ${{ env.REGISTRY }}/appimage:${{ github.sha }}
            ${{ env.REGISTRY }}/appimage:latest # Optionally push a 'latest' tag
          build-args: |
            JAR_FILE=target/*.jar # Assumes your build produces a JAR in target/

   #   - name: Scan Docker image with Trivy
        # Scans the built image for vulnerabilities.
   #     uses: aquasecurity/trivy-action@master
   #      with:
    #      image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
    #      format: 'table'
    #      exit-code: '1' # Fail the job if vulnerabilities are found
    #      ignore-unfixed: true # Ignore vulnerabilities that do not have a fix available
 #         severity: 'CRITICAL,HIGH' # Only report critical and high severity issues

  helm-packaging-deploy:
    name: Helm Packaging & Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: docker-build-scan-push # Ensures image is built, scanned, and pushed
    environment: production # Link to a GitHub environment for protection rules and secrets

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v1
        with:
          version: '3.x'

      - name: Package Helm Chart
        id: package_helm
        run: |
          CHART_NAME=$(basename ${{ env.HELM_CHART_PATH }})
          # Extract chart version from Chart.yaml
          CHART_VERSION=$(grep 'version:' ${{ env.HELM_CHART_PATH }}/Chart.yaml | awk '{print $2}')
          # Package the chart to the current working directory
          helm package ${{ env.HELM_CHART_PATH }} --destination .
          echo "chart_file=${CHART_NAME}-${CHART_VERSION}.tgz" >> $GITHUB_OUTPUT # Store the generated chart filename

      - name: Retrieve Kubeconfig for Kubernetes Deployment
        # This example assumes `KUBECONFIG` secret holds your cluster's kubeconfig content.
        # For cloud-specific clusters (EKS, GKE, AKS), consider using dedicated OIDC-based actions
        # (e.g., google-github-actions/get-gke-credentials, aws-actions/configure-aws-credentials, azure/aks-set-context).
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Deploy to Kubernetes with Helm
        # This will upgrade an existing Helm release or install a new one.
        # It uses the packaged chart file and sets image properties dynamically.
        run: |
          HELM_PACKAGE_NAME="${{ steps.package_helm.outputs.chart_file }}"
          echo "Deploying Helm chart: ${HELM_PACKAGE_NAME}"
          helm upgrade --install ${{ env.APP_NAME }} \
            "${HELM_PACKAGE_NAME}" \
            --namespace ${{ vars.KUBERNETES_NAMESPACE || 'default' }} \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ github.sha }} \
            --set image.pullPolicy=Always \
            --wait # Wait for the release to be in a ready state (pods running, etc.)

  notifications:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: helm-packaging-deploy # Trigger after deployment
    if: always() # Always run this job, regardless of previous job's success/failure

    steps:
      - name: Send Slack notification
        # Replace with your preferred notification method (e.g., Email, Teams, etc.)
        # This action requires a SLACK_WEBHOOK_URL secret.
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_CHANNEL: '#devops-alerts' # Optional, defaults to webhook default channel
          SLACK_COLOR: ${{ job.status == 'success' && 'good' || 'danger' }}
          SLACK_MESSAGE: |
            CI/CD Pipeline Run ${{ github.run_number }} (${{ github.ref_name }}) finished!
            Status: ${{ job.status }}
            Repository: ${{ github.repository }}
            Commit: ${{ github.sha }}
            Workflow: ${{ github.workflow }}
            Link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
