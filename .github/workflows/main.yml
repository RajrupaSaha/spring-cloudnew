apiVersion: jenkins.io/v1
kind: Pipeline
metadata:
  name: test-pipeline
spec:
  agent:
    image: node:18 # NOTE: This agent image (node:18) might not have 'docker', 'helm', 'trivy', 'git' pre-installed.
                   # For a real pipeline, consider a more comprehensive build image or use Jenkins X build packs.
  stages:
    - name: Checkout
      steps:
        - command: |
            echo "Repository automatically checked out by Jenkins X into the workspace."
            echo "Current directory: $(pwd)"
            # The original pipeline had `git clone ... cd repo`. For the primary repository,
            # Jenkins X clones it automatically. If you need to clone a *secondary* repo, adjust this step.

    - name: Install Dependencies
      steps:
        - command: |
            echo "Installing dependencies"
            # Assuming current working directory is the project root
            npm install

    - name: Build
      steps:
        - command: |
            echo "Building application"
            # Assuming current working directory is the project root
            npm run build

    - name: Run Tests
      steps:
        - command: |
            echo "Running unit tests"
            # Assuming current working directory is the project root
            npm test

    - name: Security Scan
      steps:
        - command: |
            echo "Running application security scan (e.g., SAST, Dependency Scan)"
            # Placeholder command. Replace with actual security scanner for your tech stack.
            # Examples: `snyk test --all-projects`, `npm audit`, `bandit -r .`, `sonarqube-scanner`
            echo "Application security scan completed (placeholder)"

    - name: Archive Build Artifacts
      steps:
        - command: |
            echo "Archiving application build artifacts"
            # Assuming 'dist/' directory is created by 'npm run build'
            tar -czf build.tar.gz dist/ || echo "Warning: dist/ directory not found for archiving."
            echo "Archived build.tar.gz"

    - name: Docker Build
      steps:
        - command: |
            echo "Building Docker image"
            # Define image name and registry. Assuming Dockerfile is in the project root.
            export APP_NAME="my-node-app"
            export IMAGE_TAG="$(git rev-parse --short HEAD)" # Using Git commit SHA as image tag
            export REGISTRY_HOST="your-docker-registry.com" # e.g., Docker Hub, GCR, ECR

            docker build -t ${REGISTRY_HOST}/${APP_NAME}:${IMAGE_TAG} .
            echo "Docker image ${REGISTRY_HOST}/${APP_NAME}:${IMAGE_TAG} built successfully"

    - name: Docker Scan
      steps:
        - command: |
            echo "Scanning Docker image for vulnerabilities"
            # Placeholder for a Docker image scanner like Trivy, Clair, Anchore.
            # Ensure the chosen scanner is installed on the agent or used as a sidecar.
            export APP_NAME="my-node-app"
            export IMAGE_TAG="$(git rev-parse --short HEAD)"
            export REGISTRY_HOST="your-docker-registry.com"

            # Example using Trivy:
            # trivy image --exit-code 1 --severity CRITICAL,HIGH ${REGISTRY_HOST}/${APP_NAME}:${IMAGE_TAG}
            echo "Docker image scan completed (placeholder)"

    - name: Push Image
      steps:
        - command: |
            echo "Pushing Docker image to registry"
            export APP_NAME="my-node-app"
            export IMAGE_TAG="$(git rev-parse --short HEAD)"
            export REGISTRY_HOST="your-docker-registry.com"

            # Authenticate to Docker registry if it's private (uncomment and configure secrets)
            # echo "$DOCKER_PASSWORD" | docker login --username "$DOCKER_USERNAME" --password-stdin ${REGISTRY_HOST}

            docker push ${REGISTRY_HOST}/${APP_NAME}:${IMAGE_TAG}
            echo "Docker image ${REGISTRY_HOST}/${APP_NAME}:${IMAGE_TAG} pushed successfully"

    - name: Packaging (Helm Chart)
      steps:
        - command: |
            echo "Packaging Helm Chart"
            # Assuming Helm chart files are located in './charts/my-node-app' relative to project root.
            export APP_NAME="my-node-app"
            export IMAGE_TAG="$(git rev-parse --short HEAD)"
            export REGISTRY_HOST="your-docker-registry.com"
            export HELM_CHART_PATH="./charts/${APP_NAME}"

            # Ensure image details are updated in the Helm chart values.yaml (common practice)
            # This often involves dynamic updates or using `--set` flags during deployment.
            # Example using yq or sed to update values.yaml directly in the pipeline:
            # yq e '.image.repository = "${REGISTRY_HOST}/${APP_NAME}" | .image.tag = "${IMAGE_TAG}"' -i ${HELM_CHART_PATH}/values.yaml
            echo "Preparing Helm chart with image: ${REGISTRY_HOST}/${APP_NAME}:${IMAGE_TAG} (placeholder for values update)"

            # Lint the Helm chart for best practices
            helm lint ${HELM_CHART_PATH}

            # Package the Helm chart into a .tgz archive
            mkdir -p ./helm-dist
            helm package ${HELM_CHART_PATH} -d ./helm-dist
            echo "Helm chart packaged to ./helm-dist/"

    - name: Deploy to Kubernetes
      steps:
        - command: |
            echo "Deploying to Kubernetes via Helm"
            export KUBE_NAMESPACE="default" # Target Kubernetes namespace
            export APP_NAME="my-node-app"
            export IMAGE_TAG="$(git rev-parse --short HEAD)"
            export REGISTRY_HOST="your-docker-registry.com"

            # Assuming `kubectl` and `helm` are configured to connect to the target Kubernetes cluster.
            # Use helm upgrade --install to create or update the release.
            helm upgrade --install \
              ${APP_NAME} \
              ./helm-dist/${APP_NAME}-*.tgz \
              --namespace ${KUBE_NAMESPACE} \
              --set image.repository=${REGISTRY_HOST}/${APP_NAME} \
              --set image.tag=${IMAGE_TAG} \
              --wait # Wait for the deployment to complete and become ready

            echo "Application ${APP_NAME} deployed to Kubernetes namespace ${KUBE_NAMESPACE} using Helm."

    - name: Notifications
      steps:
        - command: |
            echo "Pipeline completed successfully. Application deployed to Kubernetes."
            # Add more sophisticated notification logic here (e.g., Slack, Email, Microsoft Teams)
            # Example for Slack:
            # curl -X POST -H 'Content-type: application/json' \
            # --data '{"text":"Pipeline test-pipeline for my-node-app completed successfully and deployed to Kubernetes!"}' \
            # YOUR_SLACK_WEBHOOK_URL
            echo "Notification sent (placeholder)."
