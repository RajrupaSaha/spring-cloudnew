stages:
  - build
  - test
  - security_scan
  - docker_build
  - docker_scan
  - push_image
  - package_helm
  - deploy
  - notify

variables:
  APP_NAME: my-java-application
  CI_COMMIT_SHORT_SHA: ${CI_COMMIT_SHORT_SHA:-latest} # Placeholder for CI environment variable
  CI_JOB_STATUS: ${CI_JOB_STATUS:-success} # Placeholder for CI environment variable

  # Docker Registry Configuration
  DOCKER_REGISTRY_URL: myregistry.io # e.g., myregistry.io, ghcr.io, docker.io
  DOCKER_USERNAME: $DOCKER_USERNAME # CI/CD Secret
  DOCKER_PASSWORD: $DOCKER_PASSWORD # CI/CD Secret
  DOCKER_IMAGE: $DOCKER_REGISTRY_URL/$APP_NAME
  DOCKER_TAG: $CI_COMMIT_SHORT_SHA

  # Kubernetes Deployment Configuration
  KUBE_CONTEXT: my-kubernetes-cluster/production # Name of your Kubernetes context
  KUBE_NAMESPACE: default # Target Kubernetes namespace
  KUBECONFIG_BASE64: $KUBECONFIG_BASE64 # CI/CD Secret: base64 encoded kubeconfig

  # Helm Chart Configuration
  HELM_CHART_PATH: ./helm/$APP_NAME # Path to your Helm chart directory
  HELM_RELEASE_NAME: $APP_NAME
  HELM_CHART_VERSION: 0.1.0 # Or use a dynamic version like $CI_COMMIT_SHORT_SHA

  # Notification Configuration
  SLACK_WEBHOOK_URL: $SLACK_WEBHOOK_URL # CI/CD Secret

build_java_app:
  stage: build
  image: maven:3.8.6-openjdk-11 # Using OpenJDK 11 for Java build
  script:
    - echo "--- Building Java Application ---"
    - mvn clean install -DskipTests # Build JAR/WAR, skip tests for now

run_unit_tests:
  stage: test
  image: maven:3.8.6-openjdk-11
  script:
    - echo "--- Running Unit and Integration Tests ---"
    - mvn test # Execute tests

security_scan_code:
  stage: security_scan
  image: owasp/dependency-check:latest # Scan for known vulnerabilities in dependencies
  script:
    - echo "--- Running OWASP Dependency Check ---"
    - dependency-check.sh --project "$APP_NAME" --scan . --format HTML --out dependency-check-report --failOnCVSS 7
  artifacts:
    paths:
      - dependency-check-report/dependency-check-report.html
    when: always

docker_build_image:
  stage: docker_build
  image: docker:20.10.16-dind # Docker-in-Docker for building images
  services:
    - docker:20.10.16-dind
  script:
    - echo "--- Building Docker Image ---"
    - docker build -t $DOCKER_IMAGE:$DOCKER_TAG .

docker_scan_image:
  stage: docker_scan
  image: aquasec/trivy:0.40.0 # Image vulnerability scanner
  script:
    - echo "--- Scanning Docker Image for Vulnerabilities ---"
    - trivy image --exit-code 1 --severity HIGH --light $DOCKER_IMAGE:$DOCKER_TAG # Exit on HIGH severity

push_docker_image:
  stage: push_image
  image: docker:20.10.16-dind
  services:
    - docker:20.10.16-dind
  script:
    - echo "--- Logging into Docker Registry ---"
    - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin $DOCKER_REGISTRY_URL
    - echo "--- Pushing Docker Image ---"
    - docker push $DOCKER_IMAGE:$DOCKER_TAG

package_helm_chart:
  stage: package_helm
  image: alpine/helm:3.10.0 # Helm client for packaging
  script:
    - echo "--- Packaging Helm Chart ---"
    - helm package $HELM_CHART_PATH --version $HELM_CHART_VERSION --app-version $DOCKER_TAG
  artifacts:
    paths:
      - $APP_NAME-$HELM_CHART_VERSION.tgz # The packaged chart tarball

deploy_to_kubernetes:
  stage: deploy
  image: alpine/helm:3.10.0 # Helm client for deployment
  script:
    - echo "--- Configuring Kubeconfig ---"
    - mkdir -p ~/.kube
    - echo "$KUBECONFIG_BASE64" | base64 -d > ~/.kube/config
    - chmod 600 ~/.kube/config
    - export KUBECONFIG=~/.kube/config
    - kubectl config use-context $KUBE_CONTEXT
    - echo "--- Deploying Helm Chart to Kubernetes ---"
    - helm upgrade --install $HELM_RELEASE_NAME $APP_NAME-$HELM_CHART_VERSION.tgz --namespace $KUBE_NAMESPACE --set image.repository=$DOCKER_IMAGE --set image.tag=$DOCKER_TAG --wait
  dependencies:
    - package_helm_chart # Ensure the packaged chart is available from previous stage

send_notifications:
  stage: notify
  image: alpine/curl:3.17.3 # Simple image with curl for notifications
  script:
    - echo "--- Sending Deployment Notifications ---"
    - |
      if [ "$CI_JOB_STATUS" == "success" ]; then
        MESSAGE=" CI/CD Pipeline for *$APP_NAME* (Tag: *$DOCKER_TAG*) deployed successfully to *$KUBE_CONTEXT* in namespace *$KUBE_NAMESPACE*."
        COLOR="#2eb886"
      else
        MESSAGE=" CI/CD Pipeline for *$APP_NAME* (Tag: *$DOCKER_TAG*) deployment *failed* to *$KUBE_CONTEXT* in namespace *$KUBE_NAMESPACE*."
        COLOR="#ff0000"
      fi
    - |
      curl -X POST -H 'Content-type: application/json' --data "{\"attachments\":[{\"fallback\":\"$MESSAGE\",\"color\":\"$COLOR\",\"text\":\"$MESSAGE\"}]}" "$SLACK_WEBHOOK_URL"
  when: always # Run this job regardless of previous job's success or failure
